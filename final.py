# -*- coding: utf-8 -*-
"""FINAL

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Fpym-WI_jkD2haPkmKPy5FH4dUxUKiCv
"""

import math
import random

# Par√°metros globales
F = 0.5                  # Constante para latencia de recuperaci√≥n
THETA = 0.7              # Aleatoriedad en elecci√≥n de producci√≥n
UMBRAL_RECUPERACION = 1.5  # Umbral m√≠nimo para recuperar un chunk

# Clase CHUNK (unidad de conocimiento)
class Chunk:
    def __init__(self, concepto, definicion, analogia=None, fuente_externa=None):
        self.concepto = concepto                      # Nombre del concepto
        self.definicion = definicion                  # Definici√≥n formal
        self.analogia = analogia                      # Analog√≠a usada para explicar
        self.fuente_externa = fuente_externa          # Ejemplo o herramienta externa (CSD)
        self.frecuencia = 1                           # Cu√°ntas veces se usa
        self.recencia = 1                             # Tiempo desde el √∫ltimo uso
        self.associaciones = {}                       # Asociaci√≥n sem√°ntica (contexto)
        self.estimulo_externo = 0.0                   # Activaci√≥n extra por entorno distribuido
        self.ruido = random.gauss(0, 0.1)             # Ruido estoc√°stico (distribuci√≥n gaussiana)

    # Calcular activaci√≥n A_i
    def calcular_activacion(self, contexto=None, pesos=None):
        B = math.log(self.frecuencia / self.recencia + 1)  # Activaci√≥n base
        suma_asociaciones = 0
        if contexto and pesos:
            for j, c in enumerate(contexto):
                fuerza = self.associaciones.get(c, 0.0)
                suma_asociaciones += pesos[j] * fuerza
        A = B + suma_asociaciones + self.estimulo_externo + self.ruido
        self.activacion = A
        return A

    # Calcular tiempo de recuperaci√≥n
    def tiempo_recuperacion(self):
        return F * math.exp(-self.activacion)

# Clase MEMORIA DECLARATIVA
class MemoriaDeclarativa:
    def __init__(self):
        self.chunks = []

    def agregar(self, chunk):
        self.chunks.append(chunk)

    def buscar(self, termino, contexto=None, pesos=None, externo=False):
        mejor_chunk = None
        max_A = float('-inf')
        for ch in self.chunks:
            if termino.lower() in ch.concepto.lower():
                if externo:
                    ch.estimulo_externo = 0.5  # Activaci√≥n distribuida
                A = ch.calcular_activacion(contexto, pesos)
                if A > max_A:
                    max_A = A
                    mejor_chunk = ch
        return mejor_chunk if max_A > UMBRAL_RECUPERACION else None

# Funci√≥n para cargar 5 conceptos ISO 9001:2015
def crear_memoria_iso():
    memoria = MemoriaDeclarativa()

    c1 = Chunk(
        "Enfoque basado en procesos",
        "Gesti√≥n de actividades como procesos interrelacionados que contribuyen al valor del cliente.",
        "Como una orquesta: cada instrumento (proceso) aporta a la sinfon√≠a.",
        "Foro ISO, infograf√≠a digital, simulaci√≥n empresarial"
    )
    c1.associaciones = {"orquesta": 0.8, "flujo": 0.6}
    memoria.agregar(c1)

    c2 = Chunk(
        "Mejora continua",
        "Compromiso permanente con la mejora del desempe√±o global.",
        "Como escalar una monta√±a paso a paso.",
        "Estudio de caso, retroalimentaci√≥n grupal"
    )
    c2.associaciones = {"monta√±a": 0.9, "escalada": 0.6}
    memoria.agregar(c2)

    c3 = Chunk(
        "Enfoque al cliente",
        "Satisfacer y superar las expectativas del cliente es el objetivo central.",
        "Como un restaurante que adapta sus recetas seg√∫n las opiniones de los comensales.",
        "Encuestas de satisfacci√≥n, plataformas de rese√±as"
    )
    c3.associaciones = {"cliente": 0.9, "satisfacci√≥n": 0.7}
    memoria.agregar(c3)

    c4 = Chunk(
        "Liderazgo",
        "Los l√≠deres establecen direcci√≥n y fomentan una cultura de compromiso.",
        "Como el capit√°n de un barco que gu√≠a el rumbo de su tripulaci√≥n.",
        "Simuladores de liderazgo, entrevistas con directivos"
    )
    c4.associaciones = {"capit√°n": 0.85, "direcci√≥n": 0.6}
    memoria.agregar(c4)

    c5 = Chunk(
        "Toma de decisiones basada en la evidencia",
        "Las decisiones eficaces se fundamentan en el an√°lisis de datos y hechos.",
        "Como un m√©dico que receta basado en ex√°menes cl√≠nicos, no suposiciones.",
        "Indicadores de gesti√≥n, trazabilidad, informes anal√≠ticos"
    )
    c5.associaciones = {"datos": 0.8, "hechos": 0.7}
    memoria.agregar(c5)

    return memoria

def aprendizaje(memoria):
    print("\nüß† Simulaci√≥n ACTR-Analogic - Aprendizaje ISO 9001:2015")

    opciones = [
        "1. Enfoque basado en procesos",
        "2. Mejora continua",
        "3. Enfoque al cliente",
        "4. Liderazgo",
        "5. Toma de decisiones basada en la evidencia"
    ]

    print("\nüìö Conceptos disponibles:")
    for o in opciones:
        print(f"   {o}")

    seleccion = input("\n‚û°Ô∏è Escribe el n√∫mero del concepto que deseas aprender (1 a 5): ").strip()

    if seleccion == "1":
        termino = "Enfoque basado en procesos"
    elif seleccion == "2":
        termino = "Mejora continua"
    elif seleccion == "3":
        termino = "Enfoque al cliente"
    elif seleccion == "4":
        termino = "Liderazgo"
    elif seleccion == "5":
        termino = "Toma de decisiones basada en la evidencia"
    else:
        print("‚ùå Opci√≥n no v√°lida.")
        return

    contexto = input("üîé Palabras clave relacionadas (separadas por espacio): ").strip().split()

    if not contexto:
        print("‚ö†Ô∏è Debes ingresar al menos una palabra clave.")
        return

    pesos = [1.0 / len(contexto)] * len(contexto)

    chunk = memoria.buscar(termino, contexto, pesos, externo=True)

    if chunk:
        print(f"\nüìò Definici√≥n: {chunk.definicion}")
        print(f"\nüîÅ Analog√≠a aplicada: {chunk.analogia}")
        print(f"\nüåê Fuente externa: {chunk.fuente_externa}")
        print(f"\n‚è±Ô∏è Tiempo de recuperaci√≥n: {round(chunk.tiempo_recuperacion(), 2)} segundos")
        print(f"üî• Activaci√≥n total: {round(chunk.activacion, 2)}")
    else:
        print("‚ùå No se pudo recuperar el concepto (activaci√≥n insuficiente).")

# Ejecutar la simulaci√≥n
memoria = crear_memoria_iso()
aprendizaje(memoria)

# Funci√≥n para calcular el Resultado Cognitivo (RC)
def resultado_cognitivo(base_RC=0.6, usa_RA=True, usa_CSD=True):
    lambda_RA = 0.3 if usa_RA else 0.0
    lambda_CSD = 0.4 if usa_CSD else 0.0
    RC = base_RC + lambda_RA + lambda_CSD
    return round(RC, 2)

# Simulaci√≥n de c√°lculo del resultado cognitivo
print("\nüßÆ C√°lculo del Resultado Cognitivo:")

# Preguntar si se us√≥ razonamiento anal√≥gico
usa_RA = input("¬øSe aplic√≥ una analog√≠a? (s/n): ").strip().lower() == "s"
# Preguntar si hubo apoyo externo (CSD)
usa_CSD = input("¬øHubo apoyo de una fuente externa o colaborativa? (s/n): ").strip().lower() == "s"

# Calcular resultado
rc_final = resultado_cognitivo(0.6, usa_RA, usa_CSD)
print(f"\n‚úÖ Resultado Cognitivo estimado: {rc_final}")

import math

# Funci√≥n Softmax para seleccionar acciones cognitivas
def softmax_seleccion(utilidades, theta=0.7):
    exps = [math.exp(u / theta) for u in utilidades]
    total = sum(exps)
    probabilidades = [round(e / total, 4) for e in exps]
    return probabilidades

# Acciones posibles (producciones cognitivas)
acciones = [
    "Explicar con analog√≠a",
    "Buscar fuente externa",
    "Leer documento oficial",
    "Preguntar en foro colaborativo"
]

# Utilidades estimadas de cada acci√≥n (mayor = mejor)
utilidades = [0.9, 0.7, 0.5, 0.8]  # Puedes modificarlas

# Calcular probabilidades con softmax
probabilidades = softmax_seleccion(utilidades)

# Mostrar resultados
print("\nüéØ Probabilidades de seleccionar cada acci√≥n (Softmax):\n")
for i in range(len(acciones)):
    print(f"- {acciones[i]}: {probabilidades[i]*100:.1f}%")

# C√°lculo de Interacci√≥n Cognitiva Distribuida
def calcular_ICD(grados_influencia, pesos_fuentes):
    ICD = sum(w * i for w, i in zip(pesos_fuentes, grados_influencia))
    return round(ICD, 2)

# Simulaci√≥n de fuentes activas
fuentes = [
    "Profesor experto",
    "Simulaci√≥n ISO digital",
    "Compa√±ero de equipo",
    "IA educativa (como ChatGPT)"
]

# Nivel de implicaci√≥n cognitiva (0.0 a 1.0)
influencias = [0.9, 0.7, 0.6, 0.8]

# Peso asignado a cada fuente (confiabilidad, experiencia, acceso)
pesos = [0.9, 0.7, 0.5, 0.8]

# Calcular ICD
icd = calcular_ICD(influencias, pesos)

# Mostrar resultados
print("\nüîó Interacci√≥n Cognitiva Distribuida (ICD):")
for i in range(len(fuentes)):
    print(f"- {fuentes[i]}: I={influencias[i]}  | W={pesos[i]}")
print(f"\n‚úÖ Nivel total de interacci√≥n cognitiva distribuida: {icd}")

pip install streamlit

!pip install streamlit

# Commented out IPython magic to ensure Python compatibility.
# %%writefile actr_analogic_app.py
# import streamlit as st
# import math
# 
# # Configurar la p√°gina
# st.set_page_config(
#     page_title="Simulaci√≥n Cognitiva ACTR-Analogic",
#     layout="centered",
#     initial_sidebar_state="expanded"
# )
# 
# # T√≠tulo de la app
# st.title("üß† Simulaci√≥n Cognitiva ACTR-Analogic")
# st.subheader("Norma ISO 9001:2015 ‚Äì Aprendizaje Basado en Cognici√≥n Distribuida y Razonamiento Anal√≥gico")
# 
# # Descripci√≥n introductoria
# st.markdown("""
# Esta aplicaci√≥n simula c√≥mo una persona aprende conceptos clave de la norma **ISO 9001:2015**
# utilizando analog√≠as y activaci√≥n cognitiva distribuida.
# Est√° basada en la arquitectura **ACTR-Analogic**, un modelo que ampl√≠a ACT-R
# para integrar herramientas digitales, interacciones sociales y analog√≠as como mecanismos de aprendizaje h√≠brido.
# 
# ---
# 
# **¬øQu√© podr√°s hacer aqu√≠?**
# 
# - üìò Aprender un concepto ISO con analog√≠as.
# - üìà Ver c√≥mo se activa cognitivamente esa informaci√≥n.
# - üîÅ Simular el resultado cognitivo.
# - üîó Explorar el impacto de la interacci√≥n distribuida.
# 
# Desarrollado con ‚ù§Ô∏è en Streamlit.
# """)
# 
# # -------------------------------------
# # SESI√ìN 2: M√≥dulo de Aprendizaje ACTR-Analogic
# # -------------------------------------
# 
# st.markdown("---")
# st.header("üìò Aprendizaje de conceptos ISO 9001:2015")
# 
# # Diccionario de conceptos con analog√≠a y fuente externa
# conceptos_iso = {
#     "Enfoque basado en procesos": {
#         "definicion": "Gesti√≥n de actividades como procesos interrelacionados que contribuyen al valor del cliente.",
#         "analogia": "Como una orquesta: cada instrumento (proceso) aporta a la sinfon√≠a.",
#         "fuente": "Simulaci√≥n empresarial, mapa de procesos"
#     },
#     "Mejora continua": {
#         "definicion": "Compromiso permanente con la mejora del desempe√±o global.",
#         "analogia": "Como escalar una monta√±a paso a paso.",
#         "fuente": "Estudio de caso, retroalimentaci√≥n grupal"
#     },
#     "Enfoque al cliente": {
#         "definicion": "Satisfacer y superar las expectativas del cliente es el objetivo central.",
#         "analogia": "Como un restaurante que adapta sus recetas seg√∫n las opiniones de los comensales.",
#         "fuente": "Encuestas de satisfacci√≥n, rese√±as digitales"
#     },
#     "Liderazgo": {
#         "definicion": "Los l√≠deres establecen direcci√≥n y fomentan una cultura de compromiso.",
#         "analogia": "Como el capit√°n de un barco que gu√≠a a su tripulaci√≥n.",
#         "fuente": "Simuladores de liderazgo, entrevistas con directivos"
#     },
#     "Toma de decisiones basada en evidencia": {
#         "definicion": "Las decisiones eficaces se fundamentan en el an√°lisis de datos y hechos.",
#         "analogia": "Como un m√©dico que receta basado en ex√°menes cl√≠nicos, no suposiciones.",
#         "fuente": "Dashboards, indicadores de calidad"
#     }
# }
# 
# with st.form("form_aprendizaje"):
#     concepto = st.selectbox("Selecciona un concepto ISO:", list(conceptos_iso.keys()))
#     contexto = st.text_input("üîé Palabras clave relacionadas (separadas por espacio)", "")
#     submitted = st.form_submit_button("üß† Simular Aprendizaje")
# 
#     if submitted:
#         datos = conceptos_iso[concepto]
#         palabras = contexto.split()
#         activacion = 1.0 + 0.3 * len(palabras)
#         tiempo = round(0.5 * (2.7 ** (-activacion)), 2)
# 
#         st.success("‚úÖ Concepto recuperado con √©xito")
#         st.markdown(f"**üìò Definici√≥n:** {datos['definicion']}")
#         st.markdown(f"**üîÅ Analog√≠a sugerida:** _{datos['analogia']}_")
#         st.markdown(f"**üåê Fuente externa sugerida:** {datos['fuente']}")
#         st.markdown(f"**üî• Activaci√≥n simulada:** `{round(activacion, 2)}`")
#         st.markdown(f"**‚è±Ô∏è Tiempo estimado de recuperaci√≥n:** `{tiempo} segundos`")
# 
#         st.text_area("‚úçÔ∏è Escribe tu propia analog√≠a (opcional):")
#         st.multiselect("üåç Herramientas/personas que te ayudaron a aprender:",
#                        ["ChatGPT", "Foros acad√©micos", "Videos explicativos", "Compa√±eros", "Simuladores", "Docente"])
#

!streamlit run actr_analogic_app.py & npx localtunnel --port 8501